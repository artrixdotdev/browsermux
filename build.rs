use std::fs::OpenOptions;
use std::io::Write;
use std::os::unix::fs::PermissionsExt;
use std::{env, fs};

include!("src/settings.rs");

fn out_dir() -> PathBuf {
   let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());

   let profile = env::var("PROFILE").unwrap(); // "debug" or "release"

   manifest_dir.join("target").join(&profile)
}

fn generate_pkgbuild() {
   let mut pkgbuild = String::new();

   let path = out_dir().join("PKGBUILD");

   let mut file = OpenOptions::new()
      .write(true)
      .create(true)
      .truncate(true)
      .open(&path)
      .unwrap();

   let maintainers = env!("CARGO_PKG_AUTHORS").split(':').collect::<Vec<_>>();

   assert!(
      !maintainers.is_empty(),
      "Cargo.toml must have at least one maintainer"
   );

   let pkgname = env!("CARGO_PKG_NAME");
   let pkgver = env!("CARGO_PKG_VERSION");
   let license = env!("CARGO_PKG_LICENSE");
   let description = env!("CARGO_PKG_DESCRIPTION");
   let homepage = env!("CARGO_PKG_HOMEPAGE");
   let source = env!("CARGO_PKG_REPOSITORY");
   let bin = env!("CARGO_PKG_NAME"); // Binary name, change if necessary
   let triple = std::env::var("TARGET").unwrap();
   let arch = triple.split('-').next().unwrap();
   let source = format!("{source}/releases/download/v{pkgver}/{bin}-{triple}.tar.xz");

   // Dependencies
   let deps: Vec<String> = vec![];

   let conflicts = [bin.to_string()];

   let optdeps: Vec<(String, Option<String>)> = vec![];

   pkgbuild
      .push_str("# This PKGBUILD was automatically generated by build.rs. Do not edit directly.\n");

   pkgbuild.push_str(
      &maintainers
         .iter()
         .map(|m| format!("# Maintainer: {m}\n"))
         .collect::<String>(),
   );

   pkgbuild.push('\n');
   pkgbuild.push_str(&format!("pkgname={pkgname}\n"));
   pkgbuild.push_str(&format!("pkgver={pkgver}\n"));
   pkgbuild.push_str("pkgrel=1\n");
   pkgbuild.push_str(&format!("pkgdesc='{description}'\n"));
   pkgbuild.push_str(&format!("arch=({arch})\n"));
   pkgbuild.push_str(&format!("url='{homepage}'\n"));
   pkgbuild.push_str(&format!("license=({license})\n"));
   pkgbuild.push_str(&format!("provides=({bin})\n"));
   pkgbuild.push_str(&format!("depends=({})\n", deps.join(" ")));
   pkgbuild.push_str(&format!("conflicts=({})\n", conflicts.join(" ")));

   let optdeps: Vec<_> = optdeps
      .into_iter()
      .map(|(d, r)| match r {
         Some(reason) => format!("{d}: {reason}"),
         None => d,
      })
      .collect();

   pkgbuild.push_str(&format!("optdepends=({})\n", optdeps.join(" ")));

   pkgbuild.push('\n');
   pkgbuild.push_str(&format!("source=('{source}')\n"));
   pkgbuild.push_str("sha256sums=('INSERT_SHA256')\n");

   pkgbuild.push_str(&format!(
      r#"
package() {{
    cd "$srcdir"

    # Install binary
    install -Dm755 {bin} "$pkgdir/usr/bin/{bin}"

    # Install license
    install -Dm644 LICENSE "$pkgdir/usr/share/licenses/{pkgname}/LICENSE"
}}
"#,
   ));

   file.write_all(pkgbuild.as_bytes()).unwrap();

   println!("cargo:warning=PKGBUILD file is generated at {path:?}");
}

fn generate_inject_hash_script() {
   let triple = std::env::var("TARGET").unwrap();
   let bin = env!("CARGO_PKG_NAME"); // Binary name, change if necessary

   let path = out_dir().join("inject_hash.sh");
   let mut file = OpenOptions::new()
      .write(true)
      .create(true)
      .truncate(true)
      .open(&path)
      .unwrap();

   // Executable permissions
   file
      .set_permissions(PermissionsExt::from_mode(0o755))
      .unwrap();

   let mut script = String::new();

   script.push_str("#!/bin/bash\n");
   // Only run on linux
   script.push_str("if [ \"$(uname)\" = \"Linux\" ]; then\n");

   script.push_str(&format!("echo \"{bin} is being built for {triple}\"\n"));

   script.push_str(&format!(
      "HASH=$(cut -d' ' -f1 target/distrib/{bin}-{triple}.tar.xz.sha256)\n"
   ));

   script.push_str("sed -i \"s|INSERT_SHA256|$HASH|\" target/release/PKGBUILD\n");
   script.push_str("fi\n");

   file.write_all(script.as_bytes()).unwrap();

   println!("cargo:warning=inject_hash.sh file is generated at {path:?}");
}

fn generate_schema() {
   let path = out_dir().join("schema.json");
   let mut file = OpenOptions::new()
      .write(true)
      .create(true)
      .truncate(true)
      .open(&path)
      .unwrap();
   let schema = schemars::schema_for!(Settings);
   let schema = serde_json::to_vec_pretty(&schema).unwrap();

   file.write_all(schema.as_slice()).unwrap();

   println!("cargo:warning=schema file is generated at {path:?}");
}

fn main() {
   generate_schema();
   #[cfg(target_os = "linux")]
   #[cfg(target_arch = "x86_64")]
   generate_pkgbuild();

   generate_inject_hash_script(); // This script only runs on linux, but we generate it on every
   // platform since it already contains an internal OS check
}
